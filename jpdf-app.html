<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JPDF - PDF/Image to Editable PPTX</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0f172a;--card:#1e293b;--border:#334155;--text:#f8fafc;--muted:#94a3b8;--accent:#6366f1;--accent2:#818cf8;--green:#22c55e;--red:#ef4444;--yellow:#eab308}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column}
a{color:var(--accent2)}
.container{max-width:900px;margin:0 auto;padding:24px;width:100%}
h1{font-size:1.5rem;font-weight:700;display:flex;align-items:center;gap:10px}
h1 span{background:linear-gradient(135deg,var(--accent),#ec4899);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.subtitle{color:var(--muted);font-size:.85rem;margin-top:4px}
header{padding:20px 0;border-bottom:1px solid var(--border)}
.settings{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:20px 0}
.setting{display:flex;flex-direction:column;gap:4px}
.setting label{font-size:.75rem;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:.05em}
.setting input,.setting select{background:var(--card);border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:8px;font-size:.875rem;outline:none;transition:border .2s}
.setting input:focus,.setting select:focus{border-color:var(--accent)}
.setting.full{grid-column:1/-1}
.dropzone{border:2px dashed var(--border);border-radius:16px;padding:48px 24px;text-align:center;cursor:pointer;transition:all .3s;margin:20px 0;background:var(--card)}
.dropzone:hover,.dropzone.drag{border-color:var(--accent);background:rgba(99,102,241,.08)}
.dropzone.drag{transform:scale(1.01)}
.dropzone-icon{font-size:3rem;margin-bottom:12px;opacity:.5}
.dropzone-text{font-size:1rem;color:var(--muted)}
.dropzone-hint{font-size:.75rem;color:var(--muted);margin-top:8px;opacity:.6}
.dropzone input[type=file]{display:none}
.progress-wrap{margin:20px 0;display:none}
.progress-bar{height:6px;background:var(--card);border-radius:3px;overflow:hidden}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),#ec4899);width:0%;transition:width .3s;border-radius:3px}
.progress-status{display:flex;justify-content:space-between;margin-top:8px;font-size:.8rem;color:var(--muted)}
.step-list{margin:12px 0;font-size:.8rem}
.step{padding:4px 0;color:var(--muted);display:flex;align-items:center;gap:8px}
.step.active{color:var(--yellow)}.step.done{color:var(--green)}.step.error{color:var(--red)}
.step-dot{width:6px;height:6px;border-radius:50%;background:var(--border);flex-shrink:0}
.step.active .step-dot{background:var(--yellow);box-shadow:0 0 6px var(--yellow)}
.step.done .step-dot{background:var(--green)}.step.error .step-dot{background:var(--red)}
.preview-section{margin:20px 0;display:none}
.preview-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px;margin-top:12px}
.preview-card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden}
.preview-card img{width:100%;display:block}
.preview-card .label{padding:8px;font-size:.75rem;color:var(--muted);text-align:center}
.btn{display:inline-flex;align-items:center;gap:8px;padding:10px 20px;border:none;border-radius:10px;font-size:.875rem;font-weight:600;cursor:pointer;transition:all .2s}
.btn-primary{background:linear-gradient(135deg,var(--accent),#7c3aed);color:white}
.btn-primary:hover{opacity:.9;transform:translateY(-1px)}
.btn-primary:disabled{opacity:.4;cursor:not-allowed;transform:none}
.btn-success{background:var(--green);color:white}.btn-success:hover{opacity:.9}
.btn-outline{background:transparent;border:1px solid var(--border);color:var(--text)}
.btn-outline:hover{border-color:var(--accent);color:var(--accent2)}
.actions{display:flex;gap:10px;margin:20px 0;flex-wrap:wrap}
.result{margin:20px 0;padding:20px;background:var(--card);border:1px solid var(--green);border-radius:12px;display:none}
.result h3{color:var(--green);margin-bottom:8px;font-size:1rem}
.result p{color:var(--muted);font-size:.85rem}
.stats{display:flex;gap:20px;margin-top:12px}
.stat{text-align:center}.stat-value{font-size:1.5rem;font-weight:700;color:var(--text)}
.stat-label{font-size:.7rem;color:var(--muted);text-transform:uppercase}
.mode-toggle{display:flex;background:var(--card);border:1px solid var(--border);border-radius:10px;overflow:hidden;margin:20px 0}
.mode-btn{flex:1;padding:10px;text-align:center;font-size:.8rem;font-weight:600;cursor:pointer;transition:all .2s;border:none;background:transparent;color:var(--muted)}
.mode-btn.active{background:var(--accent);color:white}
.log{margin-top:12px;max-height:200px;overflow-y:auto;font-family:'Fira Code',monospace;font-size:.7rem;color:var(--muted);background:rgba(0,0,0,.3);padding:10px;border-radius:8px;line-height:1.6}
.log .warn{color:var(--yellow)}.log .err{color:var(--red)}.log .ok{color:var(--green)}
@media(max-width:640px){.settings{grid-template-columns:1fr}.stats{flex-wrap:wrap}}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><span>JPDF</span> Converter <small style="font-size:.6rem;color:var(--muted);font-weight:400">v2.0</small></h1>
    <p class="subtitle">PDF / Image &rarr; Editable PPTX &mdash; Google Vision OCR + Inpainting</p>
  </header>

  <div class="settings">
    <div class="setting full">
      <label>Google Vision API Key</label>
      <input type="password" id="apiKey" placeholder="AIza... (Google Cloud Console에서 발급)" />
    </div>
    <div class="setting">
      <label>Font</label>
      <select id="fontFamily">
        <option value="Malgun Gothic" selected>맑은 고딕</option>
        <option value="NanumGothic">나눔고딕</option>
        <option value="Arial">Arial</option>
        <option value="Calibri">Calibri</option>
        <option value="Times New Roman">Times New Roman</option>
      </select>
    </div>
    <div class="setting">
      <label>Font Size (0 = Auto)</label>
      <input type="number" id="fontSize" value="0" min="0" max="72" />
    </div>
  </div>

  <div class="mode-toggle">
    <button class="mode-btn active" data-mode="editable" onclick="setMode('editable')">&#9998; Editable (텍스트 제거 + 편집 가능)</button>
    <button class="mode-btn" data-mode="direct" onclick="setMode('direct')">&#128196; Direct (원본 배경 + 텍스트 오버레이)</button>
  </div>

  <div class="dropzone" id="dropzone" onclick="document.getElementById('fileInput').click()">
    <div class="dropzone-icon">&#128196;</div>
    <div class="dropzone-text">PDF, PNG, JPG 파일을 드래그하거나 클릭하세요</div>
    <div class="dropzone-hint">최대 50MB &bull; PDF는 여러 페이지 지원</div>
    <input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" />
  </div>

  <div class="progress-wrap" id="progressWrap">
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="progress-status">
      <span id="progressText">준비 중...</span>
      <span id="progressPct">0%</span>
    </div>
    <div class="step-list" id="stepList"></div>
    <div class="log" id="log"></div>
  </div>

  <div class="preview-section" id="previewSection">
    <h3 style="font-size:.9rem;color:var(--muted)">페이지 미리보기</h3>
    <div class="preview-grid" id="previewGrid"></div>
  </div>

  <div class="actions" id="actions" style="display:none">
    <button class="btn btn-primary" id="convertBtn" onclick="startConvert()">&#9889; 변환 시작</button>
    <button class="btn btn-outline" onclick="resetAll()">&#8634; 초기화</button>
  </div>

  <div class="result" id="result">
    <h3>&#10003; 변환 완료!</h3>
    <p id="resultText"></p>
    <div class="stats" id="resultStats"></div>
    <div style="margin-top:16px">
      <button class="btn btn-success" id="downloadBtn">&#11015; PPTX 다운로드</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// JPDF v2.0 Standalone — PDF/Image → Editable PPTX
// Fixed: font size, text positioning, paragraph-level parsing
// ============================================================

// --- PDF.js setup (v3.x legacy build — proper Worker support) ---
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

(async function main() {

// --- Constants ---
const SLIDE_W = 13.333; // inches (16:9)
const SLIDE_H = 7.5;
const RENDER_SCALE = 2.0;

// --- State ---
let state = {
  file: null,
  mode: 'editable',
  pages: [],       // { canvas, width, height, dataUrl }
  ocrResults: [],  // arrays of TextBox objects per page
  pptxBlob: null,
};

window.setMode = (mode) => {
  state.mode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
};

// --- Logging ---
function log(msg, cls = '') {
  const el = document.getElementById('log');
  el.innerHTML += `<div class="${cls}">${new Date().toLocaleTimeString()} ${msg}</div>`;
  el.scrollTop = el.scrollHeight;
}

function setProgress(pct, text) {
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressPct').textContent = Math.round(pct) + '%';
  if (text) document.getElementById('progressText').textContent = text;
}

function setStep(steps) {
  document.getElementById('stepList').innerHTML = steps.map(s =>
    `<div class="step ${s.status}"><div class="step-dot"></div>${s.label}</div>`
  ).join('');
}

// --- File Handling ---
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');

['dragenter','dragover'].forEach(e => dropzone.addEventListener(e, ev => { ev.preventDefault(); dropzone.classList.add('drag'); }));
['dragleave','drop'].forEach(e => dropzone.addEventListener(e, ev => { ev.preventDefault(); dropzone.classList.remove('drag'); }));
dropzone.addEventListener('drop', ev => handleFile(ev.dataTransfer.files[0]));
fileInput.addEventListener('change', ev => { if (ev.target.files[0]) handleFile(ev.target.files[0]); });

async function handleFile(file) {
  if (!file) return;
  const ext = file.name.split('.').pop().toLowerCase();
  if (!['pdf','png','jpg','jpeg'].includes(ext)) {
    alert('PDF, PNG, JPG 파일만 지원합니다.');
    return;
  }
  if (file.size > 50 * 1024 * 1024) {
    alert('파일 크기는 50MB 이하만 지원합니다.');
    return;
  }

  state.file = file;
  state.pages = [];
  state.ocrResults = [];
  state.pptxBlob = null;

  document.getElementById('previewSection').style.display = 'block';
  document.getElementById('previewGrid').innerHTML = '';
  document.getElementById('result').style.display = 'none';

  dropzone.innerHTML = `<div class="dropzone-icon">&#128196;</div><div class="dropzone-text">${file.name} (${(file.size/1024/1024).toFixed(1)}MB)</div><div class="dropzone-hint">클릭하여 다른 파일 선택</div><input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" style="display:none" />`;
  document.getElementById('fileInput').addEventListener('change', ev => { if (ev.target.files[0]) handleFile(ev.target.files[0]); });

  if (ext === 'pdf') {
    await loadPDF(file);
  } else {
    await loadImage(file);
  }

  document.getElementById('actions').style.display = 'flex';
}

async function loadPDF(file) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const numPages = pdf.numPages;

  for (let i = 1; i <= numPages; i++) {
    const page = await pdf.getPage(i);
    const viewport = page.getViewport({ scale: RENDER_SCALE });
    const canvas = document.createElement('canvas');
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;

    const dataUrl = canvas.toDataURL('image/png');
    state.pages.push({ canvas, width: canvas.width, height: canvas.height, dataUrl });

    const img = document.createElement('img');
    img.src = dataUrl;
    const card = document.createElement('div');
    card.className = 'preview-card';
    card.appendChild(img);
    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = `Page ${i} / ${numPages}`;
    card.appendChild(label);
    document.getElementById('previewGrid').appendChild(card);
  }
}

async function loadImage(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const dataUrl = canvas.toDataURL('image/png');
        state.pages.push({ canvas, width: img.width, height: img.height, dataUrl });

        const previewImg = document.createElement('img');
        previewImg.src = dataUrl;
        const card = document.createElement('div');
        card.className = 'preview-card';
        card.appendChild(previewImg);
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = file.name;
        card.appendChild(label);
        document.getElementById('previewGrid').appendChild(card);
        resolve();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

// ============================================================
// OCR — Paragraph-level parsing with accurate font sizing
// ============================================================

async function ocrPage(dataUrl, apiKey) {
  const base64 = dataUrl.split(',')[1];
  const payload = {
    requests: [{
      image: { content: base64 },
      features: [{ type: 'DOCUMENT_TEXT_DETECTION' }]
    }]
  };

  const resp = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  if (!resp.ok) {
    const err = await resp.json();
    throw new Error(`Vision API Error: ${err.error?.message || resp.statusText}`);
  }

  const data = await resp.json();
  return data.responses[0];
}

/**
 * Parse OCR at PARAGRAPH level — each paragraph = one text box
 * No aggressive merging — preserves original slide layout
 */
function parseOCRToParagraphs(response, pageWidth, pageHeight) {
  const textBoxes = [];
  const annotation = response?.fullTextAnnotation;
  if (!annotation || !annotation.pages) return textBoxes;

  // Scale factors: image pixels → PPTX inches
  const scaleX = SLIDE_W / pageWidth;
  const scaleY = SLIDE_H / pageHeight;

  for (const page of annotation.pages) {
    for (const block of (page.blocks || [])) {
      for (const para of (block.paragraphs || [])) {

        // Collect words with their bounding boxes
        let paraText = '';
        const words = [];

        for (const word of (para.words || [])) {
          let wordText = '';
          for (const sym of (word.symbols || [])) {
            wordText += sym.text;
            const br = sym.property?.detectedBreak?.type;
            if (br === 'SPACE' || br === 'SURE_SPACE') wordText += ' ';
            else if (br === 'EOL_SURE_SPACE' || br === 'LINE_BREAK') wordText += '\n';
          }
          paraText += wordText;

          const verts = word.boundingBox?.vertices || [];
          if (verts.length >= 4) {
            const xs = verts.map(v => v.x || 0);
            const ys = verts.map(v => v.y || 0);
            words.push({
              text: wordText.trim(),
              x: Math.min(...xs),
              y: Math.min(...ys),
              w: Math.max(...xs) - Math.min(...xs),
              h: Math.max(...ys) - Math.min(...ys),
            });
          }
        }

        paraText = paraText.trim();
        if (!paraText || words.length === 0) continue;

        // Use paragraph bounding box (more accurate than computing from words)
        const paraVerts = para.boundingBox?.vertices || [];
        let px, py, pw, ph;

        if (paraVerts.length >= 4) {
          const xs = paraVerts.map(v => v.x || 0);
          const ys = paraVerts.map(v => v.y || 0);
          px = Math.min(...xs);
          py = Math.min(...ys);
          pw = Math.max(...xs) - px;
          ph = Math.max(...ys) - py;
        } else {
          // Fallback to word bounds
          px = Math.min(...words.map(w => w.x));
          py = Math.min(...words.map(w => w.y));
          const x2 = Math.max(...words.map(w => w.x + w.w));
          const y2 = Math.max(...words.map(w => w.y + w.h));
          pw = x2 - px;
          ph = y2 - py;
        }

        // --- Font size: use scaleY to convert from image px to PPTX points ---
        // wordHeight (px) * scaleY (inches/px) * 72 (pt/inch) = height in PPTX pts
        // fontSize ≈ 65% of full word height (accounts for ascenders/descenders/padding)
        const wordHeights = words.map(w => w.h).filter(h => h > 0);
        wordHeights.sort((a, b) => a - b);
        const medianH = wordHeights.length > 0
          ? wordHeights[Math.floor(wordHeights.length / 2)]
          : 20;

        let fontSize = Math.round(medianH * scaleY * 72 * 0.62);
        fontSize = Math.max(6, Math.min(72, fontSize));

        // --- Alignment detection ---
        let alignment = 'left';
        if (words.length > 1 && pw > 0) {
          // Group words by Y position (lines)
          const lineMap = new Map();
          for (const w of words) {
            const lineY = Math.round(w.y / (medianH * 0.5)) * Math.round(medianH * 0.5);
            if (!lineMap.has(lineY)) lineMap.set(lineY, []);
            lineMap.get(lineY).push(w);
          }

          if (lineMap.size >= 2) {
            // Check if lines are centered within paragraph bounds
            let centeredCount = 0;
            for (const [, lineWords] of lineMap) {
              const lineLeft = Math.min(...lineWords.map(w => w.x));
              const lineRight = Math.max(...lineWords.map(w => w.x + w.w));
              const lineCenter = (lineLeft + lineRight) / 2;
              const paraCenter = px + pw / 2;
              if (Math.abs(lineCenter - paraCenter) < pw * 0.15) centeredCount++;
            }
            if (centeredCount >= lineMap.size * 0.6) alignment = 'center';
          }
        }

        // --- Line spacing ---
        const lines = paraText.split('\n').filter(l => l.trim());
        const lineCount = Math.max(1, lines.length);
        let lineSpacing = 1.0;
        if (lineCount > 1 && fontSize > 0) {
          const heightInPts = ph * scaleY * 72;
          lineSpacing = heightInPts / (lineCount * fontSize * 1.2);
          lineSpacing = Math.max(0.8, Math.min(2.5, lineSpacing));
        }

        textBoxes.push({
          text: paraText,
          // Image pixel coordinates (for inpainting)
          imgX: px, imgY: py, imgW: pw, imgH: ph,
          // PPTX coordinates in inches
          x: px * scaleX,
          y: py * scaleY,
          w: pw * scaleX + 0.1, // small padding to prevent word wrap
          h: ph * scaleY + 0.05,
          fontSize,
          alignment,
          lineSpacing: Math.round(lineSpacing * 100) / 100,
          wordCount: words.length,
        });
      }
    }
  }

  return textBoxes;
}

// ============================================================
// Inpainting — Canvas-based background fill
// ============================================================

function inpaintPage(canvas, textBoxes, padding = 8) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  const imageData = ctx.getImageData(0, 0, w, h);
  const data = imageData.data;

  for (const box of textBoxes) {
    const x1 = Math.max(0, box.imgX - padding);
    const y1 = Math.max(0, box.imgY - padding);
    const x2 = Math.min(w, box.imgX + box.imgW + padding);
    const y2 = Math.min(h, box.imgY + box.imgH + padding);

    // Sample border pixels (5px bands around the region)
    const borderPixels = [];
    const band = 5;
    const sampleEdge = (sx, sy, ex, ey) => {
      for (let yy = sy; yy < ey; yy++) {
        for (let xx = sx; xx < ex; xx++) {
          if (xx >= 0 && xx < w && yy >= 0 && yy < h) {
            const idx = (yy * w + xx) * 4;
            borderPixels.push([data[idx], data[idx+1], data[idx+2]]);
          }
        }
      }
    };

    sampleEdge(x1, Math.max(0, y1 - band), x2, y1);
    sampleEdge(x1, y2, x2, Math.min(h, y2 + band));
    sampleEdge(Math.max(0, x1 - band), y1, x1, y2);
    sampleEdge(x2, y1, Math.min(w, x2 + band), y2);

    if (borderPixels.length === 0) continue;

    let rSum = 0, gSum = 0, bSum = 0;
    for (const [r, g, b] of borderPixels) { rSum += r; gSum += g; bSum += b; }
    const n = borderPixels.length;
    const avgR = Math.round(rSum / n);
    const avgG = Math.round(gSum / n);
    const avgB = Math.round(bSum / n);

    // Fill with edge blending
    for (let yy = y1; yy < y2; yy++) {
      for (let xx = x1; xx < x2; xx++) {
        const idx = (yy * w + xx) * 4;
        const dx = Math.min(xx - x1, x2 - xx - 1);
        const dy = Math.min(yy - y1, y2 - yy - 1);
        const dist = Math.min(dx, dy);
        const blendRange = 4;
        const t = dist < blendRange ? dist / blendRange : 1.0;
        data[idx]     = Math.round(data[idx]     * (1 - t) + avgR * t);
        data[idx + 1] = Math.round(data[idx + 1] * (1 - t) + avgG * t);
        data[idx + 2] = Math.round(data[idx + 2] * (1 - t) + avgB * t);
      }
    }
  }

  ctx.putImageData(imageData, 0, 0);
  return canvas;
}

// ============================================================
// PPTX Generation — Precise text box positioning
// ============================================================

function generatePPTX(pages, ocrResults, options) {
  const pptx = new PptxGenJS();
  pptx.defineLayout({ name: 'WIDE', width: SLIDE_W, height: SLIDE_H });
  pptx.layout = 'WIDE';

  for (let i = 0; i < pages.length; i++) {
    const page = pages[i];
    const textBoxes = ocrResults[i] || [];
    const slide = pptx.addSlide();

    // --- Background image ---
    let bgDataUrl = page.dataUrl;
    if (options.mode === 'editable' && textBoxes.length > 0) {
      const cleanCanvas = document.createElement('canvas');
      cleanCanvas.width = page.width;
      cleanCanvas.height = page.height;
      const ctx = cleanCanvas.getContext('2d');
      ctx.drawImage(page.canvas, 0, 0);
      inpaintPage(cleanCanvas, textBoxes);
      bgDataUrl = cleanCanvas.toDataURL('image/png');
    }

    slide.addImage({
      data: bgDataUrl,
      x: 0, y: 0, w: SLIDE_W, h: SLIDE_H
    });

    // --- Text boxes (each paragraph = one text box) ---
    for (const box of textBoxes) {
      const fs = options.fontSize > 0 ? options.fontSize : box.fontSize;
      const textColor = '333333';

      // Split into lines and create text objects
      const lines = box.text.split('\n').filter(l => l.trim());
      const textBody = lines.map(line => ({
        text: line,
        options: {
          fontSize: fs,
          fontFace: options.fontFamily,
          color: textColor,
          align: box.alignment === 'center' ? 'center' : box.alignment === 'right' ? 'right' : 'left',
          lineSpacingMultiple: box.lineSpacing,
          breakType: 'break',
        }
      }));

      slide.addText(textBody, {
        x: box.x,
        y: box.y,
        w: box.w,
        h: box.h,
        valign: 'top',
        margin: [0, 0, 0, 0],
        fill: { color: 'FFFFFF', transparency: 100 },
        shrinkText: true, // shrink if text overflows
      });
    }
  }

  return pptx;
}

// ============================================================
// Main Convert
// ============================================================

window.startConvert = async function() {
  const apiKey = document.getElementById('apiKey').value.trim();
  if (!apiKey) { alert('Google Vision API Key를 입력해주세요.'); return; }
  if (state.pages.length === 0) { alert('파일을 먼저 선택해주세요.'); return; }

  const fontFamily = document.getElementById('fontFamily').value;
  const fontSize = parseInt(document.getElementById('fontSize').value) || 0;

  const progressWrap = document.getElementById('progressWrap');
  const convertBtn = document.getElementById('convertBtn');
  progressWrap.style.display = 'block';
  convertBtn.disabled = true;
  document.getElementById('result').style.display = 'none';
  document.getElementById('log').innerHTML = '';

  const totalPages = state.pages.length;
  const steps = [
    { label: 'OCR 텍스트 인식 (paragraph 단위)', status: 'active' },
    { label: '이미지 처리 (Inpainting)', status: '' },
    { label: 'PPTX 생성', status: '' },
  ];
  setStep(steps);
  log('변환을 시작합니다... (v2.0 — paragraph-level parsing)', 'ok');

  try {
    // Step 1: OCR
    state.ocrResults = [];
    for (let i = 0; i < totalPages; i++) {
      setProgress((i / totalPages) * 50, `OCR 처리 중... (${i + 1}/${totalPages})`);
      log(`[OCR] Page ${i + 1}/${totalPages} 처리 중...`);

      try {
        const ocrResponse = await ocrPage(state.pages[i].dataUrl, apiKey);
        const textBoxes = parseOCRToParagraphs(
          ocrResponse,
          state.pages[i].width,
          state.pages[i].height
        );
        state.ocrResults.push(textBoxes);

        const avgFontSize = textBoxes.length > 0
          ? Math.round(textBoxes.reduce((a, b) => a + b.fontSize, 0) / textBoxes.length)
          : 0;
        log(`[OCR] Page ${i + 1}: ${textBoxes.length}개 텍스트 박스 (avg ${avgFontSize}pt)`, 'ok');
      } catch (err) {
        log(`[OCR] Page ${i + 1} 에러: ${err.message}`, 'err');
        state.ocrResults.push([]);
      }
    }
    steps[0].status = 'done';
    steps[1].status = 'active';
    setStep(steps);

    // Step 2: Inpainting
    setProgress(60, '이미지 처리 중...');
    log(`[Inpaint] 모드: ${state.mode}`, 'ok');
    steps[1].status = 'done';
    steps[2].status = 'active';
    setStep(steps);

    // Step 3: Generate PPTX
    setProgress(75, 'PPTX 생성 중...');
    log('[PPTX] 슬라이드 생성 중...');

    const pptx = generatePPTX(state.pages, state.ocrResults, {
      mode: state.mode,
      fontFamily,
      fontSize
    });

    setProgress(90, 'PPTX 파일 저장 중...');
    const blob = await pptx.write({ outputType: 'blob' });
    state.pptxBlob = blob;

    steps[2].status = 'done';
    setStep(steps);
    setProgress(100, '완료!');

    const totalBoxes = state.ocrResults.reduce((a, b) => a + b.length, 0);
    log(`[완료] ${totalPages}페이지, ${totalBoxes}개 텍스트 박스`, 'ok');

    // Show result
    const result = document.getElementById('result');
    result.style.display = 'block';
    document.getElementById('resultText').textContent =
      `${state.file.name} → ${totalPages}페이지, ${totalBoxes}개 텍스트 박스가 편집 가능하게 변환되었습니다.`;

    document.getElementById('resultStats').innerHTML = `
      <div class="stat"><div class="stat-value">${totalPages}</div><div class="stat-label">Pages</div></div>
      <div class="stat"><div class="stat-value">${totalBoxes}</div><div class="stat-label">Text Boxes</div></div>
      <div class="stat"><div class="stat-value">${(blob.size/1024/1024).toFixed(1)}MB</div><div class="stat-label">File Size</div></div>
    `;

    document.getElementById('downloadBtn').onclick = () => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = state.file.name.replace(/\.[^.]+$/, '') + '_editable.pptx';
      a.click();
      URL.revokeObjectURL(url);
    };

  } catch (err) {
    log(`[에러] ${err.message}`, 'err');
    console.error(err);
    steps.forEach(s => { if (s.status === 'active') s.status = 'error'; });
    setStep(steps);
    alert('변환 중 오류가 발생했습니다: ' + err.message);
  }

  convertBtn.disabled = false;
};

window.resetAll = function() {
  state = { file: null, mode: state.mode, pages: [], ocrResults: [], pptxBlob: null };
  document.getElementById('progressWrap').style.display = 'none';
  document.getElementById('previewSection').style.display = 'none';
  document.getElementById('actions').style.display = 'none';
  document.getElementById('result').style.display = 'none';
  document.getElementById('previewGrid').innerHTML = '';
  dropzone.innerHTML = `<div class="dropzone-icon">&#128196;</div><div class="dropzone-text">PDF, PNG, JPG 파일을 드래그하거나 클릭하세요</div><div class="dropzone-hint">최대 50MB &bull; PDF는 여러 페이지 지원</div><input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" style="display:none" />`;
  document.getElementById('fileInput').addEventListener('change', ev => { if (ev.target.files[0]) handleFile(ev.target.files[0]); });
};

})(); // end main IIFE
</script>
</body>
</html>
